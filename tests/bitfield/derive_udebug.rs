#![cfg(feature = "ufmt")]

//! Tests for `#[derive(uDebug)]`

extern crate alloc;

use core::fmt::{Debug, Write};
use modular_bitfield::error::InvalidBitPattern;
use modular_bitfield::prelude::*;
use ufmt::derive::uDebug;
use ufmt::{uDebug, uWrite, uwrite, Formatter};
use modular_bitfield_impl::bitfield_reflect;

pub struct AllocString(alloc::string::String);

impl uWrite for AllocString {
    type Error = ();

    fn write_str(&mut self, s: &str) -> Result<(), Self::Error> {
        self.0.write_str(s).map_err(|_| ())
    }
}

impl AllocString {
    pub fn new() -> Self {
        Self(alloc::string::String::new())
    }
}

impl<'s> PartialEq<&'s str> for AllocString {
    fn eq(&self, other: &&'s str) -> bool {
        self.0 == *other
    }
}

impl Debug for AllocString {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        self.0.fmt(f)
    }
}

/// Wrapper for ufmt's uwrite!() macro to return an AllocString, analogous to the format!() macro.
macro_rules! ufmt_format_wrapper {
    ($($tt:tt)*) => {{
        let mut s = AllocString::new();
        uwrite!(s, $($tt)*).unwrap();
        s
    }};
}

#[test]
fn print_invalid_bits() {
    // ----------------------------------------------
    // This enum and its impl uDebug would have to be created by the user
    pub enum FieldValueOrError<F, E> {
        /// Read field value
        FieldValue(F),
        /// Error returned when trying to read a field
        Error(E),
    }

    impl<F: uDebug, E: uDebug> uDebug for FieldValueOrError<F, E> {
        #[inline]
        fn fmt<W>(&self, f: &mut ufmt::Formatter<'_, W>) -> Result<(), W::Error>
        where
            W: uWrite + ?Sized,
        {
            match self {
                FieldValueOrError::FieldValue(value) => value.fmt(f),
                FieldValueOrError::Error(value) => value.fmt(f),
            }
        }
    }
    //
    // ----------------------------------------------

    #[derive(Specifier, uDebug)]
    #[bits = 2]
    pub enum Status {
        Green = 0,
        Yellow = 1,
        Red = 2, // 0x11 (= 3) is undefined here for Status!
    }

    #[bitfield]
    pub struct DataPackage {
        status: Status,
        contents: B4,
        is_alive: bool,
        is_received: bool,
    }

    // TODO: Comment only for discussion
    // ----------------------------------------------
    // Generated by #[bitfield] from here
    //
    impl DataPackage {
        // TODO: Comment only for discussion
        // Everything is const to get the most out of compiler optimizations (and because there really MUSTN'T be anything non-const here)

        // TODO: Comment only for discussion
        // Needed to get the struct's name later in #[bitfield_reflect]
        const fn struct_name() -> &'static str {
            "DataPackage"
        }

        // TODO: Comment only for discussion
        // Needed to be able to compare to the number of fields later passed to #[bitfield_reflect(num_fields = 4)]
        const fn num_fields() -> usize {
            4
        }

        // TODO: Comment only for discussion
        // Needed to abstract the field name away to be able to use it in a general way in #[bitfield_reflect]
        const fn field1_name() -> &'static str {
            "status"
        }

        // TODO: Comment only for discussion
        // Needed to abstract the field type away to be able to use it in a general way in #[bitfield_reflect]
        const fn field1_getter() -> fn(&DataPackage) -> Result<Status, InvalidBitPattern<u8>> {
            DataPackage::status_or_err
        }

        const fn field2_name() -> &'static str {
            "contents"
        }

        const fn field2_getter() -> fn(&DataPackage) -> Result<u8, InvalidBitPattern<u8>> {
            DataPackage::contents_or_err
        }

        const fn field3_name() -> &'static str {
            "is_alive"
        }

        const fn field3_getter() -> fn(&DataPackage) -> Result<bool, InvalidBitPattern<u8>> {
            DataPackage::is_alive_or_err
        }

        const fn field4_name() -> &'static str {
            "is_received"
        }

        const fn field4_getter() -> fn(&DataPackage) -> Result<bool, InvalidBitPattern<u8>> {
            DataPackage::is_received_or_err
        }
    }
    // TODO: Comment only for discussion
    //
    // Generated by #[bitfield_reflect] until here
    // ----------------------------------------------

    impl uDebug for DataPackage {
        // TODO: Compare binary size with getter without error
        // TODO: Compare binary size with normal Debug impl without _err
        // TODO: Add documentation with manual+error/manual without error (unwrap)/fields macro/fields macro without error (unwrap)/example macro which provides the same impl (with fields! macro) for a passed struct/example for Display impl
        // TODO (separate PR/optimization): Would it make sense, to implement the get_*_or_err() functions for types that cannot fail as an #[inline(always)] function which always returns Ok(*)?
        // TODO: Add a test which ensures the binary size (and also maybe the generated llvm-ir/asm?) of the same struct with #[derive(Debug)] and the same impl but done with #[bitfield_reflect] are equal
        #[bitfield_reflect(num_fields = 4)]
        fn fmt<W>(&self, f: &mut Formatter<'_, W>) -> Result<(), W::Error>
        where
            W: uWrite + ?Sized,
        {
            // TODO: Comment only for discussion
            // ----------------------------------------------
            // Generated by #[bitfield_reflect(4)] from here
            //
            const {
                // TODO: Comment only for discussion
                // This is to ensure any changes to the number of fields in the struct get caught here
                // The number 4 is taken from #[bitfield_reflect(num_fields = 4)]
                // This would only be generated if `assert_field_count` was passed to  #[bitfield_reflect]
                // It would be nice to make this a warning but AFAIK there is currently no way to do this.
                assert!(Self::num_fields() == 4);
            };

            // TODO: Comment only for discussion
            // The dead_code warnings would only be generated with `warn_unused_field` passed to #[bitfield_reflect]
            // This makes it easier to implement Debug/Display traits as changes to the number of struct fields would generate warnings
            // here if the impl would not be updated accordingly
            // TODO: Maybe this should be opt out with `no_warn_unused_field` because anyone implementing anything with reflection probably wants to be notified about unused fields
            #[warn(
                dead_code,
                reason = "Use name of field 1, or ignore it explicitly with `let _ = field1_name;`"
            )]
            #[allow(
                non_upper_case_globals,
                reason = "Provide a uniform naming scheme for field name + field getter"
            )]
            const field1_name: &'static str = DataPackage::field1_name();
            #[warn(
                dead_code,
                reason = "Use value of field 1, or ignore it explicitly with `let _ = get_field1;`"
            )]
            let get_field1 = DataPackage::field1_getter();
            #[allow(
                non_upper_case_globals,
                reason = "Provide a uniform naming scheme for field name + field getter"
            )]
            const field2_name: &'static str = DataPackage::field2_name();
            let get_field2 = DataPackage::field2_getter();
            #[allow(
                non_upper_case_globals,
                reason = "Provide a uniform naming scheme for field name + field getter"
            )]
            const field3_name: &'static str = DataPackage::field3_name();
            let get_field3 = DataPackage::field3_getter();
            #[allow(
                non_upper_case_globals,
                reason = "Provide a uniform naming scheme for field name + field getter"
            )]
            const field4_name: &'static str = DataPackage::field4_name();
            let get_field4 = DataPackage::field4_getter();

            // TODO: Comment only for discussion
            // Macro which repeats given code for each field defined above (so every struct field)
            // This enables an implementation which is the same - sans the generated code itself - for every struct
            // This in turn makes it possible to use in a user-defined macro, so an impl e.g. for ufmt::uDebug
            // would only have to be written once (in the macro) and only one macro call has to be added for each struct
            // making it _a lot_ less work/duplicated code if you have dozens of structs.
            //
            // e.g. the user could later do something like:
            /// ```rust
            /// macro_rules! my_custom_debug_impl {
            ///     ($struct:ident, $num_fields:literal) => {
            ///         impl uDebug for $struct {
            ///             #[bitfield_reflect(num_fields = $num_fields)]
            ///             fn fmt<W>(&self, f: &mut Formatter<'_, W>) -> Result<(), W::Error>
            ///             where
            ///                 W: uWrite + ?Sized,
            ///             {
            ///                 // ...
            ///             }
            ///         }
            ///     };
            /// };
            ///
            /// #[bitfield]
            /// struct Struct1 {
            ///     // ...
            /// }
            /// my_custom_udebug_impl!(Struct1, 4); // Single line needed for every struct
            /// ```
            #[allow(unused_macros, reason = "This cannot not be used if the implementation changes per field")]
            macro_rules! for_each_field {
                ($field_name:ident, $get_field:ident, $($tt:tt)+) => {
                    let $field_name = field1_name;
                    let $get_field = get_field1;
                    $($tt)+
                    let $field_name = field2_name;
                    let $get_field = get_field2;
                    $($tt)+
                    let $field_name = field3_name;
                    let $get_field = get_field3;
                    $($tt)+
                    let $field_name = field4_name;
                    let $get_field = get_field4;
                    $($tt)+
                };
            }
            // TODO: Comment only for discussion
            //
            // Generated by #[bitfield_reflect] until here
            // ----------------------------------------------

            let mut debug_struct = f.debug_struct(Self::struct_name())?;
            for_each_field!(field_name, get_field,
                debug_struct.field(
                    field_name,
                    &get_field(self).as_ref().map_or_else(
                        |e| FieldValueOrError::Error(e),
                        |v| FieldValueOrError::FieldValue(v),
                    ),
                )?;
            );
            debug_struct.finish()
        }
    }

    let package = DataPackage::from_bytes([0b0101_1011]);
    assert_eq!(
        ufmt_format_wrapper!("{:?}", package),
        "DataPackage { status: InvalidBitPattern { invalid_bytes: 3 }, contents: 6, is_alive: true, is_received: false }",
    );
    assert_eq!(
        ufmt_format_wrapper!("{:#?}", package),
        "DataPackage {\n    \
            status: InvalidBitPattern {\n        \
                invalid_bytes: 3,\n    \
            },\n    \
            contents: 6,\n    \
            is_alive: true,\n    \
            is_received: false,\n\
        }",
    );
}

#[test]
fn respects_other_derives() {
    #[bitfield]
    #[derive(Debug, uDebug, Clone, PartialEq, Eq)]
    pub struct Color {
        r: B6,
        g: B6,
        b: B6,
        a: B6,
    }

    let color1 = Color::new().with_r(63).with_g(32).with_b(16).with_a(8);
    let color2 = color1.clone();
    assert_eq!(color1, color2);
    assert_eq!(ufmt_format_wrapper!("{:?}", color1), "Color { r: 63, g: 32, b: 16, a: 8 }",);
    assert_eq!(
        ufmt_format_wrapper!("{:#?}", color2),
        "Color {\n    r: 63,\n    g: 32,\n    b: 16,\n    a: 8,\n}",
    );
}

#[test]
fn valid_use_2() {
    #[derive(Specifier, uDebug)]
    pub enum Status {
        Green,
        Yellow,
        Red,
        None,
    }

    #[bitfield]
    #[derive(uDebug)]
    pub struct DataPackage {
        status: Status,
        contents: B60,
        is_alive: bool,
        is_received: bool,
    }

    let package = DataPackage::new()
        .with_status(Status::Green)
        .with_contents(0xC0DE_CAFE)
        .with_is_alive(true)
        .with_is_received(false);
    assert_eq!(
        ufmt_format_wrapper!("{:?}", package),
        "DataPackage { status: Green, contents: 3235826430, is_alive: true, is_received: false }",
    );
    assert_eq!(
        ufmt_format_wrapper!("{:#?}", package),
        "DataPackage {\n    status: Green,\n    contents: 3235826430,\n    is_alive: true,\n    is_received: false,\n}",
    );
}

#[test]
fn valid_use_specifier() {
    #[bitfield(filled = false)] // Requires just 4 bits!
    #[derive(Specifier, uDebug)]
    pub struct Header {
        status: B2,
        is_alive: bool,
        is_received: bool,
    }

    let header = Header::new()
        .with_status(1)
        .with_is_alive(true)
        .with_is_received(false);
    assert_eq!(
        ufmt_format_wrapper!("{:?}", header),
        "Header { status: 1, is_alive: true, is_received: false }",
    );
    assert_eq!(
        ufmt_format_wrapper!("{:#?}", header),
        "Header {\n    status: 1,\n    is_alive: true,\n    is_received: false,\n}",
    );
}

#[test]
fn valid_use() {
    #[bitfield]
    #[derive(uDebug)]
    pub struct Color {
        r: B6,
        g: B6,
        b: B6,
        a: B6,
    }

    let color = Color::new().with_r(63).with_g(32).with_b(16).with_a(8);
    assert_eq!(ufmt_format_wrapper!("{:?}", color), "Color { r: 63, g: 32, b: 16, a: 8 }",);
    assert_eq!(
        ufmt_format_wrapper!("{:#?}", color),
        "Color {\n    r: 63,\n    g: 32,\n    b: 16,\n    a: 8,\n}",
    );
}

#[test]
fn valid_use_tuple() {
    #[bitfield]
    #[derive(uDebug)]
    pub struct Color(B6, B6, B6, B6);

    let color = Color::new().with_0(63).with_1(32).with_2(16).with_3(8);
    assert_eq!(ufmt_format_wrapper!("{:?}", color), "Color(63, 32, 16, 8)",);
    assert_eq!(
        ufmt_format_wrapper!("{:#?}", color),
        "Color(\n    63,\n    32,\n    16,\n    8,\n)",
    );
}
